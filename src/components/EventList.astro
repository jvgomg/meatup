---
import { getEntry } from 'astro:content';
import EventCard from './EventCard.astro';

const entry = await getEntry('events', 'events');
if (!entry) throw new Error('Events not found');
const upcomingStatuses = new Set(['scheduled']);
const normalizedEvents = entry.data.map((event) => ({
  ...event,
  status: event.status ?? 'scheduled',
  attendees: event.attendees ?? [],
}));

const eventsDescending = normalizedEvents
  .toSorted((a, b) => b.date.getTime() - a.date.getTime())
  .map((event, index, list) => {
    return {
      ...event,
      eventNumber: list.length - index,
    };
  });

const upcomingEvents = eventsDescending
  .filter((event) => upcomingStatuses.has(event.status))
  .toSorted((a, b) => b.date.getTime() - a.date.getTime());

const pastEvents = eventsDescending.filter((event) => !upcomingStatuses.has(event.status));

const totalEvents = normalizedEvents.length;
const totalAttendees = normalizedEvents.reduce(
  (sum, event) => sum + (event.attendees?.length ?? 0),
  0,
);
const uniqueAttendees = new Set(
  normalizedEvents.flatMap((event) => event.attendees ?? []),
);
const averageAttendance = totalEvents
  ? (totalAttendees / totalEvents).toFixed(1)
  : '0.0';

const venueCounts = new Map<string, number>();
for (const event of normalizedEvents) {
  if (event.primaryVenue?.name) {
    venueCounts.set(event.primaryVenue.name, (venueCounts.get(event.primaryVenue.name) ?? 0) + 1);
  }
  for (const venue of event.secondaryVenues ?? []) {
    if (venue.name) {
      venueCounts.set(venue.name, (venueCounts.get(venue.name) ?? 0) + 1);
    }
  }
}

const uniqueVenues = venueCounts.size;
let topVenue: string | null = null;
let topVenueCount = 0;
for (const [venueName, count] of venueCounts.entries()) {
  if (count > topVenueCount) {
    topVenue = venueName;
    topVenueCount = count;
  }
}

const completedCount = normalizedEvents.filter((event) => event.status === 'completed').length;
const scheduledCount = normalizedEvents.filter((event) => event.status === 'scheduled').length;
const failedCount = normalizedEvents.filter((event) => event.status === 'failed').length;

const lastHeldEvent = pastEvents[0];
const daysSinceLast =
  lastHeldEvent && lastHeldEvent.date
    ? Math.floor((Date.now() - lastHeldEvent.date.getTime()) / (1000 * 60 * 60 * 24))
    : null;

const nextEvent = upcomingEvents[0];

function formatSummaryDate(date?: Date) {
  if (!date) return '—';
  return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
}
---

<section class="event-sections">
  <div class="summary">
    <div class="summary__header">
      <p class="eyebrow">By the numbers</p>
      <p class="summary__title">Meat up snapshots</p>
    </div>
    <div class="summary__grid">
      <div class="summary__card">
        <p class="summary__label">Total meatings</p>
        <p class="summary__value">{totalEvents}</p>
        <p class="summary__meta">
          {completedCount} completed · {failedCount} failed
        </p>
      </div>
      <div class="summary__card">
        <p class="summary__label">Upcoming</p>
        <p class="summary__value">{scheduledCount}</p>
        <p class="summary__meta">
          {nextEvent ? `Next: ${formatSummaryDate(nextEvent.date)}` : 'No bookings yet'}
        </p>
      </div>
      <div class="summary__card">
        <p class="summary__label">Attendance</p>
        <p class="summary__value">{totalAttendees}</p>
        <p class="summary__meta">
          {uniqueAttendees.size} unique · avg {averageAttendance}
        </p>
      </div>
      <div class="summary__card">
        <p class="summary__label">Venues</p>
        <p class="summary__value">{uniqueVenues}</p>
        <p class="summary__meta">
          {topVenue ? `Top: ${topVenue}` : 'No venues yet'}
        </p>
      </div>
      <div class="summary__card summary__card--wide">
        <p class="summary__label">Last meatup</p>
        <p class="summary__value">
          {lastHeldEvent ? formatSummaryDate(lastHeldEvent.date) : '—'}
        </p>
        <p class="summary__meta">
          {lastHeldEvent && typeof daysSinceLast === 'number'
            ? `${daysSinceLast} days ago`
            : 'Waiting for the first one'}
        </p>
      </div>
    </div>
  </div>

  {upcomingEvents.length > 0 && (
    <div class="events-group">
      <header class="events-group__header">
        <p class="eyebrow">Upcoming meatings</p>
      </header>
      <ul class="events">
        {upcomingEvents.map((event) => (
          <EventCard {...event} />
        ))}
      </ul>
    </div>
  )}

  {pastEvents.length > 0 && (
    <div class="events-group">
      <header class="events-group__header">
        <p class="eyebrow">Past meatings</p>
      </header>
      <ul class="events">
        {pastEvents.map((event) => (
          <EventCard {...event} />
        ))}
      </ul>
    </div>
  )}
</section>

<style>
  .event-sections {
    display: grid;
    gap: var(--space-xl);
    max-width: 48rem;
    margin: 0 auto;
  }

  .summary {
    display: grid;
    gap: var(--space-m);
    padding: var(--space-m);
    border: 2px solid var(--carbon-black);
    background: linear-gradient(
        135deg,
        rgba(255, 205, 86, 0.12),
        rgba(255, 255, 255, 0.02)
      ),
      rgba(255, 255, 255, 0.04);
    box-shadow: 3px 3px 0 var(--carbon-black);
  }

  .summary__header {
    display: grid;
    gap: var(--space-3xs);
  }

  .summary__title {
    font-size: var(--text-section);
    font-weight: 700;
    margin: 0;
    line-height: 1.05;
  }

  .summary__grid {
    display: grid;
    gap: var(--space-s);
    grid-template-columns: repeat(auto-fit, minmax(13rem, 1fr));
  }

  .summary__card {
    display: grid;
    gap: var(--space-4xs);
    padding: var(--space-s);
    border-radius: var(--radius, 0.5rem);
    border: 1px solid rgba(255, 255, 255, 0.4);
    background: rgba(255, 255, 255, 0.03);
    box-shadow: 2px 2px 0 var(--carbon-black);
    position: relative;
    overflow: hidden;
  }

  .summary__card::after {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
      135deg,
      rgba(255, 205, 86, 0.12),
      transparent 65%
    );
    pointer-events: none;
  }

  .summary__card--wide {
    grid-column: span 2;
  }

  @media (max-width: 600px) {
    .summary__card--wide {
      grid-column: span 1;
    }
  }

  .summary__label {
    font-size: var(--text-ui);
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: var(--mustard-yellow);
    margin: 0;
  }

  .summary__value {
    font-size: var(--text-hero);
    font-weight: 800;
    margin: 0;
    line-height: 1;
  }

  .summary__meta {
    font-size: var(--step--1);
    opacity: 0.85;
    margin: 0;
    line-height: 1.4;
  }

  .events-group {
    display: grid;
    gap: var(--space-s);
  }

  .events-group__header {
    display: grid;
    gap: var(--space-3xs);
  }

  .eyebrow {
    font-size: var(--text-ui);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    opacity: 0.7;
  }

  .events {
    list-style: none;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-2xl);
  }
</style>
