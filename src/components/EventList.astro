---
import { getEntry } from 'astro:content';
import EventCard from './EventCard.astro';

const entry = await getEntry('events', 'events');
if (!entry) throw new Error('Events not found');
const upcomingStatuses = new Set(['scheduled']);
const normalizedEvents = entry.data.map((event) => ({
  ...event,
  status: event.status ?? 'scheduled',
  attendees: event.attendees ?? [],
}));

const eventsDescending = normalizedEvents
  .toSorted((a, b) => b.date.getTime() - a.date.getTime())
  .map((event, index, list) => {
    return {
      ...event,
      eventNumber: list.length - index,
    };
  });

const upcomingEvents = eventsDescending
  .filter((event) => upcomingStatuses.has(event.status))
  .toSorted((a, b) => b.date.getTime() - a.date.getTime());

const pastEvents = eventsDescending.filter((event) => !upcomingStatuses.has(event.status));

const totalEvents = pastEvents.length;
const totalAttendees = pastEvents.reduce((sum, event) => sum + (event.attendees?.length ?? 0), 0);
const uniqueAttendees = new Set(pastEvents.flatMap((event) => event.attendees ?? []));

const pastAttendeeTotal = pastEvents.reduce(
  (sum, event) => sum + (event.attendees?.length ?? 0),
  0,
);
const averageAttendanceValue = pastEvents.length ? pastAttendeeTotal / pastEvents.length : 0;
const averageAttendanceDisplay = averageAttendanceValue.toFixed(1);

const attendeeCounts = new Map<string, number>();
for (const event of pastEvents) {
  for (const attendee of event.attendees ?? []) {
    attendeeCounts.set(attendee, (attendeeCounts.get(attendee) ?? 0) + 1);
  }
}

let mostAttended: string[] = [];
let leastAttended: string[] = [];
let mostAttendedCount = 0;
let leastAttendedCount = Infinity;

for (const [attendee, count] of attendeeCounts.entries()) {
  if (count > mostAttendedCount) {
    mostAttended = [attendee];
    mostAttendedCount = count;
  } else if (count === mostAttendedCount) {
    mostAttended.push(attendee);
  }

  if (count < leastAttendedCount) {
    leastAttended = [attendee];
    leastAttendedCount = count;
  } else if (count === leastAttendedCount) {
    leastAttended.push(attendee);
  }
}

if (!attendeeCounts.size) {
  mostAttendedCount = 0;
  leastAttendedCount = 0;
}

const venueCounts = new Map<string, number>();
for (const event of normalizedEvents) {
  if (event.primaryVenue?.name) {
    venueCounts.set(event.primaryVenue.name, (venueCounts.get(event.primaryVenue.name) ?? 0) + 1);
  }
  for (const venue of event.secondaryVenues ?? []) {
    if (venue.name) {
      venueCounts.set(venue.name, (venueCounts.get(venue.name) ?? 0) + 1);
    }
  }
}

const uniqueVenues = venueCounts.size;
let topVenue: string | null = null;
let topVenueCount = 0;
for (const [venueName, count] of venueCounts.entries()) {
  if (count > topVenueCount) {
    topVenue = venueName;
    topVenueCount = count;
  }
}

const completedCount = pastEvents.filter((event) => event.status === 'completed').length;
const failedCount = pastEvents.filter((event) => event.status === 'failed').length;
const scheduledCount = upcomingEvents.length;

const lastHeldEvent = pastEvents[0];

const nextEvent = upcomingEvents[0];

function formatSummaryDate(date?: Date) {
  if (!date) return '—';
  return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
}

const pluralizeMeatings = (count: number) => `${count} meat${count === 1 ? 'ing' : 'ings'}`;
const formatNameList = (names: string[]) =>
  names.length ? names.toSorted((a, b) => a.localeCompare(b)).join(', ') : '—';
---

<section class="event-sections">
  <div class="summary">
    <div class="summary__header">
      <p class="eyebrow">Smokin' stats</p>
      <p class="summary__title">Meat the numbers</p>
    </div>
    <div class="summary__grid">
      <div class="summary__card">
        <p class="summary__label">Total meatings</p>
        <p
          class="summary__value"
          data-count-target={totalEvents}
          data-count-decimals="0"
        >
          {totalEvents}
        </p>
        <p class="summary__meta">
          {completedCount} completed · {failedCount} failed
        </p>
      </div>
      <div class="summary__card">
        <p class="summary__label">Upcoming</p>
        <p
          class="summary__value"
          data-count-target={scheduledCount}
          data-count-decimals="0"
        >
          {scheduledCount}
        </p>
        <p class="summary__meta">
          {nextEvent ? `Next: ${formatSummaryDate(nextEvent.date)}` : 'No bookings yet'}
        </p>
      </div>
      <div class="summary__card">
        <p class="summary__label">Attendance (avg)</p>
        <p
          class="summary__value"
          data-count-target={averageAttendanceValue}
          data-count-decimals="1"
        >
          {averageAttendanceDisplay}
        </p>
        <p class="summary__meta">
          Total {totalAttendees} · {uniqueAttendees.size} unique
        </p>
      </div>
      <div class="summary__card">
        <p class="summary__label">Most attended</p>
        <p class="summary__value summary__value--text">{formatNameList(mostAttended)}</p>
        <p class="summary__meta">
          {mostAttendedCount ? pluralizeMeatings(mostAttendedCount) : 'No attendance yet'}
        </p>
      </div>
      <div class="summary__card">
        <p class="summary__label">Least attended</p>
        <p class="summary__value summary__value--text">{formatNameList(leastAttended)}</p>
        <p class="summary__meta">
          {leastAttendedCount ? pluralizeMeatings(leastAttendedCount) : 'No attendance yet'}
        </p>
      </div>
      <div class="summary__card">
        <p class="summary__label">Venues</p>
        <p
          class="summary__value"
          data-count-target={uniqueVenues}
          data-count-decimals="0"
        >
          {uniqueVenues}
        </p>
        <p class="summary__meta">
          {topVenue ? `Top: ${topVenue}` : 'No venues yet'}
        </p>
      </div>
      <div class="summary__card summary__card--wide">
        <p class="summary__label">Last meatup</p>
        <p class="summary__value">
          {lastHeldEvent ? formatSummaryDate(lastHeldEvent.date) : '—'}
        </p>
        <p
          class="summary__meta"
          data-relative-date={lastHeldEvent?.date?.toISOString()}
        >
          {lastHeldEvent ? 'Calculating...' : 'Waiting for the first one'}
        </p>
      </div>
    </div>
  </div>

  {upcomingEvents.length > 0 && (
    <div class="events-group">
      <header class="events-group__header">
        <p class="eyebrow">Upcoming meatings</p>
        <p class="upcoming-pun" data-pun>
          Time to raise the steaks and pencil in the next one.
        </p>
      </header>
      <ul class="events">
        {upcomingEvents.map((event) => (
          <EventCard {...event} />
        ))}
      </ul>
    </div>
  )}

  {upcomingEvents.length === 0 && (
    <div class="events-group events-group--empty">
      <header class="events-group__header">
        <p class="eyebrow">Upcoming meatings</p>
        <p class="empty__title">None on the books</p>
      </header>
      <div class="empty__card">
        <p class="empty__copy">
          Calendar is bare. Someone pick a date before we end up “meeting” at the closest Subway.
        </p>
      </div>
    </div>
  )}

  {pastEvents.length > 0 && (
    <div class="events-group">
      <header class="events-group__header">
        <p class="eyebrow">Past meatings</p>
      </header>
      <ul class="events">
        {pastEvents.map((event) => (
          <EventCard {...event} />
        ))}
      </ul>
    </div>
  )}
</section>

<script>
  // Calculate relative dates client-side so they're always accurate
  document.querySelectorAll('[data-relative-date]').forEach((el) => {
    const dateStr = el.getAttribute('data-relative-date');
    if (!dateStr) return;
    const date = new Date(dateStr);
    const days = Math.floor((Date.now() - date.getTime()) / (1000 * 60 * 60 * 24));
    el.textContent = `${days} day${days === 1 ? '' : 's'} ago`;
  });

  const summary = document.querySelector('.summary');

  if (summary) {
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const statValues = summary.querySelectorAll('[data-count-target]');

    const animateValue = (element: Element, index: number) => {
      const target = Number(element.getAttribute('data-count-target') ?? '0');
      if (!Number.isFinite(target)) return;

      const decimals = Number(element.getAttribute('data-count-decimals') ?? '0');
      const duration = 1300 + index * 120;
      const start = performance.now();

      const tick = (now: number) => {
        const progress = Math.min((now - start) / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 4);
        const value = target * eased;
        element.textContent = value.toFixed(decimals);
        if (progress < 1) requestAnimationFrame(tick);
      };

      element.textContent = (0).toFixed(decimals);
      requestAnimationFrame(tick);
    };

    const revealStats = () => {
      summary.classList.add('summary--visible');
      statValues.forEach((element, index) => animateValue(element, index));
    };

    if (!prefersReducedMotion) {
      summary.classList.add('summary--animate-ready');
      const observer = new IntersectionObserver(
        (entries, obs) => {
          const hasIntersected = entries.some((entry) => entry.isIntersecting);
          if (hasIntersected) {
            revealStats();
            obs.disconnect();
          }
        },
        { threshold: 0.45 },
      );

      observer.observe(summary);
    }
  }

  const punTarget = document.querySelector<HTMLElement>('[data-pun]');
  const puns = [
    'Time to raise the steaks and pencil in the next one.',
    'Quit stall-ing—let’s herd some calendars.',
    'We need to meat in the middle before the grill goes cold.',
    'BBQ without a booking? That’s a mis-steak waiting to happen.',
    'No plan? That’s rare. Let’s get it cooked to medium soon.',
  ];
  if (punTarget && puns.length) {
    const pick = puns[Math.floor(Math.random() * puns.length)];
    punTarget.textContent = pick;
  }
</script>

<style>
  .event-sections {
    display: grid;
    gap: var(--space-xl);
    max-width: 48rem;
    margin: 0 auto;
  }

  .summary {
    display: grid;
    gap: var(--space-m);
    padding: var(--space-m);
    border: 2px solid var(--carbon-black);
    background: linear-gradient(
        135deg,
        rgba(255, 205, 86, 0.12),
        rgba(255, 255, 255, 0.02)
      ),
      rgba(255, 255, 255, 0.04);
    box-shadow: 3px 3px 0 var(--carbon-black);
  }

  .summary__header {
    display: grid;
    gap: var(--space-3xs);
  }

  .summary__title {
    font-family: var(--font-display);
    font-size: var(--text-section);
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: -0.02em;
    line-height: 0.9;
    margin: 0;
  }

  .summary__grid {
    display: grid;
    gap: var(--space-s);
    grid-template-columns: repeat(auto-fit, minmax(13rem, 1fr));
  }

  .summary__card {
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: var(--space-3xs);
    padding: var(--space-s);
    border-radius: var(--radius, 0.5rem);
    border: 1px solid rgba(255, 255, 255, 0.4);
    background: rgba(255, 255, 255, 0.03);
    box-shadow: 2px 2px 0 var(--carbon-black);
    position: relative;
    overflow: hidden;
    transition: transform 360ms ease, opacity 360ms ease, box-shadow 220ms ease;
  }

  .summary--animate-ready .summary__card {
    opacity: 0;
    transform: translateY(14px);
  }

  .summary--visible .summary__card {
    opacity: 1;
    transform: translateY(0);
  }

  .summary__card::after {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
      135deg,
      rgba(255, 205, 86, 0.12),
      transparent 65%
    );
    pointer-events: none;
  }

  .summary__card--wide {
    grid-column: span 2;
  }

  .summary--visible .summary__card:nth-child(1) {
    transition-delay: 40ms;
  }

  .summary--visible .summary__card:nth-child(2) {
    transition-delay: 80ms;
  }

  .summary--visible .summary__card:nth-child(3) {
    transition-delay: 120ms;
  }

  .summary--visible .summary__card:nth-child(4) {
    transition-delay: 160ms;
  }

  .summary--visible .summary__card:nth-child(5) {
    transition-delay: 200ms;
  }

  .summary--visible .summary__card:nth-child(6) {
    transition-delay: 240ms;
  }

  .summary--visible .summary__card:nth-child(7) {
    transition-delay: 280ms;
  }

  @media (max-width: 600px) {
    .summary__card--wide {
      grid-column: span 1;
    }
  }

  .summary__label {
    font-size: var(--text-ui);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--mustard-yellow);
    margin: 0;
  }

  .summary__value {
    font-family: var(--font-display);
    font-size: var(--text-hero);
    font-weight: 700;
    letter-spacing: -0.02em;
    line-height: 1;
    margin: 0;
  }

  .summary__value--text {
    font-size: var(--text-section);
    line-height: 1.2;
    word-break: break-word;
  }

  .summary__meta {
    font-size: var(--step--1);
    opacity: 0.85;
    margin: 0;
    line-height: 1.4;
  }

  .events-group {
    display: grid;
    gap: var(--space-s);
  }

  .events-group__header {
    display: grid;
    gap: var(--space-3xs);
  }

  .upcoming-pun {
    margin: 0;
    font-size: var(--step--1);
    opacity: 0.8;
    line-height: 1.4;
  }

  .events-group--empty {
    border: 1px dashed rgba(255, 255, 255, 0.4);
    padding: var(--space-m);
    border-radius: var(--radius, 0.75rem);
    background: rgba(255, 255, 255, 0.02);
  }

  .empty__title {
    margin: 0;
    font-size: var(--text-section);
    font-weight: 700;
  }

  .empty__card {
    margin-top: var(--space-2xs);
    padding: var(--space-s);
    border-radius: var(--radius, 0.5rem);
    border: 1px solid rgba(255, 255, 255, 0.25);
    background: rgba(255, 255, 255, 0.04);
    box-shadow: 2px 2px 0 var(--carbon-black);
  }

  .empty__copy {
    margin: 0;
    line-height: 1.5;
  }

  .eyebrow {
    font-size: var(--text-ui);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    opacity: 0.7;
    margin: 0;
  }

  .events {
    list-style: none;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-2xl);
  }
</style>
